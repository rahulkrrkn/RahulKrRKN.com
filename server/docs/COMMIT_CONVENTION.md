# Commit Convention

This document defines a strict, production-grade commit message convention for a single website repository that contains multiple projects (monorepo). It is based on Conventional Commits, extended for multi-project scope clarity and automation.

Do not deviate. CI, changelogs, release automation, and code review workflows rely on this format.

## Commit message format

All commits MUST follow this exact structure:

```
type(scope): subject

optional body

optional footer
```

- `type`: one of the allowed types (see below). Lowercase. No emojis.
- `scope`: OPTIONAL but REQUIRED when the change affects a specific project/module. Use the project or package name (see "Scopes for multi-projects"). Lowercase, hyphen-separated. Do not include path separators.
- `subject`: concise summary in imperative mood. No trailing period. Max 50 characters recommended.
- `body`: optional longer description. Wrap at 72 characters. Explain what and why (not how). If necessary, include migration steps.
- `footer`: optional metadata lines. Use for Breaking Changes, issue references, or co-authored-by lines. Use exact keywords described below.

If a change introduces a breaking API/behavior change, use `!` after the type/scope or add a `BREAKING CHANGE:` footer (see section "Breaking changes").

Example:

```
feat(auth): add OAuth2 token refresh support

Add server-side refresh token rotation and storage.

BREAKING CHANGE: stored tokens now include `rotationId`; migration script included.
```

## Allowed types (when to use them)

Each type is a keyword placed before the optional scope and colon. Use only one type per commit.

- `feat`: A new feature for the user-facing product or library.

  - When: adds user-visible functionality or public API.
  - Example: `feat(portfolio): add project filtering by tag`

- `fix`: A bug fix.

  - When: corrects incorrect behavior, resolves errors, or fixes crashes.
  - Example: `fix(admin-dashboard): correct pagination offset calculation`

- `docs`: Documentation only changes.

  - When: README, architecture docs, API docs, docstrings.
  - Example: `docs(shared): document Button component props`

- `style`: Formatting, white-space, missing semicolons ‚Äî changes that do not affect code behavior.

  - When: code formatters, linter autofixes that do not change logic.
  - Example: `style(auth): apply prettier formatting`

- `refactor`: Code change that neither fixes a bug nor adds a feature.

  - When: renames, restructures, performance-neutral refactors improving readability or architecture.
  - Example: `refactor(shared-utils): extract date parsing helper`

- `perf`: A code change that improves performance.

  - When: changes that measurably improve speed, memory, or throughput.
  - Example: `perf(api): reduce DB queries on user list endpoint`

- `test`: Adding or updating tests and test utilities.

  - When: new tests, test refactors, mocks updates.
  - Example: `test(auth): add unit tests for token rotation`

- `build`: Changes that affect the build system or external dependencies (example scopes: webpack, rollup, build-scripts).

  - When: build config, bundler, packaging changes.
  - Example: `build(client): upgrade webpack to 5.80.0`

- `ci`: Changes to CI configuration files and scripts (GitHub Actions, Azure Pipelines, etc.).

  - When: workflow files, CI pipelines, test runners in CI context.
  - Example: `ci: add caching to action/test-workflow`

- `chore`: Other changes that do not modify src or tests (package maintenance, tooling, housekeeping).

  - When: bumping dev-deps, updating script comments, or other maintenance tasks.
  - Example: `chore: update contributing guidelines`

- `revert`: Revert a previous commit. The subject should reference the reverted commit and include the original header.

  - When: explicitly reverting a commit; use the autogenerated revert message when possible.
  - Example: `revert: feat(auth): add OAuth2 token refresh support`

- `deps`: (Optional) If you prefer to separate dependency upgrades from general `chore`, you may use `deps`.
  - Example: `deps(client): update react to 18.2.0`

Only use other custom types if explicitly approved by the team and documented in this file.

## Scopes for multi-project repository

- Use `scope` to indicate the specific project, package, or module affected.
- Scope MUST be the project or package name (not a file path). Use hyphen-separated lowercase names.
- When a commit touches multiple projects, use a generic `scope` or split into multiple commits each scoped to a single project.

Examples:

- `feat(auth): add login with magic link`
- `fix(admin-dashboard): fix filter not applying`
- `refactor(shared-ui): replace legacy grid with css-grid`
- `chore: update root CI config` (use no scope for repo-wide housekeeping)

Scope naming rules:

- Single word or hyphen-separated (e.g., `shared-ui`, `admin-dashboard`).
- Do not include `client/` or `server/` prefixes ‚Äî the package name is sufficient.
- For very small, cross-cutting changes that truly affect the entire repository, omit the scope.

## Subject line rules

- Max length: 50 characters recommended for the subject. Keep it concise.
- Use imperative, present tense: "add", "fix", "remove", not "added", "fixes", or "fixing".
- Capitalization: capitalize the first word of the subject only when it is a proper noun; otherwise lowercase the first word.
- No trailing period at the end of the subject.
- No issue numbers, ticket IDs, or reviewer names in the subject. Put them in the footer if required.

Examples (subjects only):

- Good: `feat(auth): add support for SSO login`
- Bad: `Added SSO login support` ‚Äî not imperative, past tense.
- Bad: `fix: bug` ‚Äî too vague.

## Body rules

- When needed, add a body separated from the subject by a blank line.
- Wrap lines at 72 characters.
- Body should explain "what" and "why", not "how".
- Include migration steps, render-breaking notes, or testing instructions when relevant.

## Footer rules

- Use the footer for:
  - `BREAKING CHANGE:` followed by an explanation and migration steps.
  - `Closes #<issue>` or `Fixes #<issue>` to link issues.
  - `Co-authored-by: Name <email>` lines for pair commits.
- Format for breaking changes in footer:

  `BREAKING CHANGE: <description of change and migration steps>`

  Alternatively, you may mark the header with `!` (e.g., `feat!: ...`) and still include details in the footer.

## Breaking changes

- A breaking change is any change that requires consumers to change code or configuration.
- Mark breaking changes in one of two ways:
  1. Add `!` after the type or after the scope: `feat(scope)!: subject`
  2. Or include a `BREAKING CHANGE:` footer with a detailed explanation and migration steps.
- The footer MUST include:
  - A concise description of the break.
  - Concrete migration steps.
  - Version bump recommendation if applicable.

Example:

```
refactor(api)!: normalize user id to numeric

User IDs are now integers (previously strings). Update client parsing.

BREAKING CHANGE: client must convert user id values using `Number(user.id)`.
```

## Hotfixes

- Hotfix commits should still follow the convention. Use a descriptive scope.
- Branch naming: `hotfix/<project>-short-description`.
- Example commit on hotfix branch: `fix(api): prevent crash when profile missing`

For emergency releases, prefer small, focused commits and include a clear changelog entry in the PR.

## Reverts

- Use `revert:` as the type and include the original commit header in the subject.
- The body should reference commit hash and reason for revert.

Example:

```
revert: feat(auth): add OAuth2 token refresh support

This reverts commit 1a2b3c4d due to token rotation causing logout regressions.
```

## Dependency updates

- Use `chore(deps):` or `deps(<scope>):` for dependency bumps when they are routine.
- For dependency upgrades that introduce feature changes or breaking API changes, use `feat`/`fix`/`refactor` as appropriate and document the impact in the body and footer.

Examples:

- `chore(deps): update eslint from 8.36.0 to 8.37.0`
- `build(client): upgrade react-scripts to 5.0.1` (if build behavior changes)

## CI/CD related commits

# Commit convention for project-layer monorepo

This repository holds one website composed of multiple projects. Each project contains two layers: `client` (frontend) and `server` (backend). This file defines a strict, production-grade commit message convention that extends Conventional Commits with mandatory, unambiguous scopes.

Follow this format exactly. Commit hooks, changelog generation, and release automation depend on it.

## Overview ‚Äî required format

All commits MUST use this header structure (single-line header):

```
<type>(<project>-<layer>): <short imperative summary>
```

- `<type>`: one of the allowed types (see "Types"). Lowercase.
- `<project>`: the canonical project name (hyphen-separated, lowercase).
- `<layer>`: either `client` or `server` (mandatory).
- `subject`: short imperative summary (no trailing punctuation). Max 50 characters recommended.

The body and footer are optional and follow Conventional Commits rules.

Full commit example:

```
feat(blog-client): add markdown editor

Add a WYSIWYG markdown editor with image upload support.

Closes #123
```

Invalid example (scope ambiguous):

```
fix: resolve jwt expiration bug
```

The above is invalid because scope is mandatory and must include project-layer.

## Types (when to use them)

Use exactly one of the following types. Each has a clear purpose.

- `feat`: A user-facing feature or new public API.

  - Use when adding new functionality.
  - Example: `feat(shop-client): add product quick-view`

- `fix`: A bug fix.

  - Use for any change that corrects incorrect behavior.
  - Example: `fix(blog-server): prevent token refresh race`

- `docs`: Documentation only changes.

  - Use for README, API docs, architecture notes, docstrings.
  - Example: `docs(shop-server): document order webhook payload`

- `style`: Formatting, whitespace, missing semicolons, linter auto-fixes that do not alter behavior.

  - Example: `style(blog-client): run prettier`

- `refactor`: Code changes that neither add a feature nor fix a bug.

  - Use for restructuring, renames, moving code, or simplifying logic.
  - Example: `refactor(shop-server): extract search service`

- `perf`: Performance improvements.

  - Use when code changes measurably improve speed, latency, memory.
  - Example: `perf(shop-server): add index to products table`

- `test`: Adding or modifying tests, test refactors, or test infrastructure.

  - Example: `test(blog-client): add integration tests for editor`

- `build`: Changes to build system, packaging, or dependencies that affect production build output.

  - Example: `build(shop-client): migrate bundler to esbuild`

- `ci`: Changes to CI/CD pipelines, workflow files, or CI scripts.

  - Example: `ci: add caching to action/test-workflow`

- `chore`: Maintenance tasks that do not modify source or tests (tooling, scripts, housekeeping).

  - Example: `chore: update contributing guidelines`

- `revert`: Revert a previous commit. Subject must mirror the original header.
  - Example: `revert: feat(blog-client): add markdown editor`

Only these types are allowed unless the team approves an extension in writing.

## Scope rules ‚Äî mandatory and strict

Scopes are REQUIRED and MUST follow this pattern:

```
<project>-<layer>
```

Rules:

- `<project>`: canonical project name (lowercase, hyphen-separated). Use package or project directory name if available.
- `<layer>`: must be exactly `client` or `server`.
- Examples of valid scopes:
  - `blog-client`
  - `blog-server`
  - `shop-client`
  - `shop-server`
- Shared code scopes (use ONLY when the change targets shared code):
  - `shared-client` ‚Äî shared frontend code
  - `shared-server` ‚Äî shared backend code
  - `shared-fullstack` ‚Äî use only when a single commit truly and unavoidably touches both layers across multiple projects

Forbidden / ambiguous scopes (do not use):

- `frontend`, `backend`, `client-only`, `server-only`, `ui`, `api`

If a change affects multiple projects or layers, split it into separate commits per project-layer. If splitting is impossible, use `shared-fullstack` and explain the multi-project impact in the body.

## Writing rules ‚Äî strict

- Imperative mood: start subject with a verb in present tense (e.g., "add", "fix", "remove").
- Subject max length: 50 characters recommended; keep it short and specific.
- Body line wrap: 72 characters.
- Capitalization: lowercase first word unless it is a proper noun (e.g., "React"). Do not use ALL CAPS.
- No trailing punctuation: do not end the subject with a period, exclamation, or question mark.
- No vague wording: avoid `update`, `fixes`, `changes` alone ‚Äî be specific.
- One change per commit: keep commits focused to a single purpose and single scope.

Examples:

- Good: `feat(blog-client): add markdown editor`
- Good: `fix(shop-server): prevent duplicate order insertion`
- Bad: `fix: prevent duplicate order` ‚Äî missing scope
- Bad: `updated code` ‚Äî vague and past tense

## Body and footer ‚Äî usage

- Body: optional. Explain "what" and "why", not low-level implementation details. Include migration steps if required.
- Footer: use for metadata:
  - `BREAKING CHANGE: <explanation and migration steps>`
  - `Closes #<issue>` or `Fixes #<issue>`
  - `Co-authored-by: Name <email>`

Breaking change markers:

- You may mark a header with `!` to indicate a breaking change: `feat(blog-server)!: change session format`
- You MUST also include a `BREAKING CHANGE:` footer with migration instructions.

## Special guidelines

Breaking changes

- Mark with `!` in header or include `BREAKING CHANGE:` in footer.
- Provide clear migration steps, affected projects/layers, and recommended version bump.

Hotfixes

- Branch naming: `hotfix/<project>-<short-description>`.
- Commits follow the normal convention and must be scoped to the project-layer.
- Keep hotfix commits minimal and include a PR describing emergency context.

Reverts

- Use `revert` type and include the original header in the subject.
- Body must include reverted commit hash and reason.

Dependency updates

- Routine dependency bumps: `chore(<project>-<layer>): update <pkg> from x to y` or `deps` if team prefers.
- If an upgrade changes behavior or API, use `feat`, `fix`, or `refactor` and document in body/footer.

CI/CD commits

- Use `ci:` for pipeline/workflow changes. If changing build output, also include `build(<project>-<layer>): ...` as appropriate.

Database and API changes

- Schema migrations, DB changes, and API contract changes are breaking by nature. Use `feat`/`refactor`/`fix` with `!` and a `BREAKING CHANGE:` footer.
- Include:
  - Migration SQL or script path
  - Rollback instructions
  - Client compatibility notes (which projects/layers are affected)

## Examples ‚Äî correct and incorrect

Correct examples

- `feat(blog-client): add markdown editor`

  - Adds new user feature to blog frontend.

- `fix(blog-server): resolve JWT expiration bug`

  - Fixes a server-side bug in JWT handling for `blog`.

- `refactor(shop-client): simplify cart state logic`

  - Refactors frontend cart logic; no behavior change.

- `perf(shop-server): optimize product search query`

  - Improves server-side performance for product search.

- `chore(shared-server): bump lodash to 4.17.21`
  - Routine dependency update scoped to shared backend utilities.

Incorrect examples and why they are incorrect

- `feat(client): add markdown editor`

  - Incorrect: ambiguous scope (`client` layer only) ‚Äî must be `blog-client`.

- `fix: resolve JWT expiration bug`

  - Incorrect: missing mandatory scope.

- `update deps`

  - Incorrect: vague type and subject; missing scope and details.

- `feat(blog): add editor`

  - Incorrect: missing layer (`blog-client` or `blog-server`).

- `chore: bump react`
  - Incorrect: missing scope and details; must be `chore(shop-client): bump react to x.y.z`.

## Why this convention exists

- Clear history: every commit explicitly states which project and layer it changes.
- Better code reviews: reviewers know impact scope immediately.
- Automated changelogs: semantic commits enable accurate release notes and changelogs per project.
- Release management: automation can determine semantic version bumps and targeted releases for individual projects.

## Enforcement and recommendations

- Enforce with commit-msg and pre-commit hooks (recommended).
- CI should fail builds when commit messages do not match this pattern.
- Prefer small, single-purpose commits. Split cross-cutting work into multiple commits.

## Quick reference

- Header: `<type>(<project>-<layer>): <subject>`
- Scope: required; `<project>-<layer>` where `<layer>` ‚àà {`client`,`server`}
- Types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`, `revert`
- Subject: imperative, ‚â§50 chars recommended, no trailing punctuation
- Body: optional; wrap at 72 chars
- Footer: `BREAKING CHANGE:` | `Closes #` | `Co-authored-by:`

2. Copy everything above
3. Commit it using:
   docs: add commit message convention

---

If you want next, I can:

- Add **branch naming documentation**
- Create a **Git workflow doc (solo/team)**
- Set up **commit linting**
- Show **real commit examples for your projects**

Just say üëç

```

```
